{"seeAlsoSections":[{"title":"The Basics","identifiers":["doc:\/\/Factory\/documentation\/Factory\/Containers","doc:\/\/Factory\/documentation\/Factory\/Scopes"],"generated":true}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/Factory"},{"type":"text","text":" manages the dependency injection process for a specific object or service and produces an object of the desired type when required."}]},{"anchor":"Defining-a-Factory","level":2,"type":"heading","text":"Defining a Factory"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Most container-based dependency injection systems require you to define that a dependency is available for injection and many require some sort of factory or mechanism that will provide a new instance of the service when needed."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Factory, as you may have guessed from the name, is no exception."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s a simple registration that creates a "},{"type":"codeVoice","code":"ServiceType"},{"type":"text","text":" dependency for us when needed."}]},{"type":"codeListing","syntax":"swift","code":["extension Container {","    var service: Factory<ServiceType> {","         self { MyService() }","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"There’s a few things going on here, so let’s break it down."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"First, we extended our container in order to define a new computed variable of type "},{"type":"codeVoice","code":"Factory<ServiceType>"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"swift","code":["extension Container {","    var service: Factory<ServiceType> {","        ...","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"ServiceType"},{"type":"text","text":" is the dependency type, and it’s often a protocol to which the returned dependency conforms."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Factory<ServiceType>"},{"type":"text","text":" is the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory"},{"type":"text","text":" that controls how and when our "},{"type":"codeVoice","code":"ServiceType"},{"type":"text","text":" dependency is made. It manages our dependency."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"So our computed variable needs to return a Factory. But Factory’s are complex creatures. They need to communicate with their enclosing containers and they need to be provided with a closure that can be called to create an instance of our dependency when required."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"As such, a complete, formal Factory definition would look like this…"}]},{"type":"codeListing","syntax":"swift","code":["var service: Factory<ServiceType> {","    Factory(self, scope: .unique) { ","        MyService()","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"But we can do better. Factory also provides a bit of syntactic sugar that asks the enclosing container to make our factory for us using a "},{"type":"codeVoice","code":"callAsFunction"},{"type":"text","text":" function on "},{"type":"codeVoice","code":"self"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"swift","code":["var service: Factory<ServiceType> {","    self { MyService() }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And we’re done. Either way, the Factory generated by the container is then returned directly to the caller, usually to be evaluated. See “Resolving a Factory” below."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Every time we resolve this particular factory we’ll get a new, unique instance of an object that matches our Factory’s type."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you’re concerned about building Factory’s on the fly, don’t be. Like SwftUI Views, Factory structs and modifiers are lightweight and transitory value types. They’re created when needed and then immediately discarded once their purpose has been served."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For more examples of Factory definitions that define scopes, use constructor injection, and do parameter passing, see: "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/Registrations"},{"type":"text","text":"."}]},{"anchor":"Resolving-a-Factory","level":2,"type":"heading","text":"Resolving a Factory"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To resolve a Factory and obtain an object or service of the desired type, one simply calls the Factory as s function. Here we use the "},{"type":"codeVoice","code":"shared"},{"type":"text","text":" container that’s provided for each and every container type."}]},{"type":"codeListing","syntax":"swift","code":["class ContentViewModel: ObservableObject {","    private let myService = Container.shared.service()","    ...","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The resolved instance may be brand new or Factory may return a cached value from the specified "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/Scope"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you’re passing an instance of a container around to your views or view models, just call it directly."}]},{"type":"codeListing","syntax":"swift","code":["private let service = container.service()"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Finally, we could have also used an "},{"type":"codeVoice","code":"@Injected"},{"type":"text","text":" property wrapper and specified a keyPath to the desired dependency."}]},{"type":"codeListing","syntax":"swift","code":["@Injected(\\.service) var service"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Unless otherwise specified, the "},{"type":"codeVoice","code":"@Injected"},{"type":"text","text":" property wrapper looks for dependencies in the standard shared container provided by Factory, so the above is functionally identical to the "},{"type":"codeVoice","code":"Container.shared.service()"},{"type":"text","text":" example shown earlier. Here’s one pointing to your own container."}]},{"type":"codeListing","syntax":"swift","code":["@Injected(\\MyCustomContainer.service) var service: ServiceType"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For more examples see: "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/Resolutions"},{"type":"text","text":"."}]},{"anchor":"Registering-a-new-Factory-closure","level":2,"type":"heading","text":"Registering a new Factory closure"},{"type":"paragraph","inlineContent":[{"type":"text","text":"What happens if we want to change the behavior of a Factory? What if the system requires changes during runtime, or what if we want our factory to provide mocks and testing doubles?"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It’s easy. Just register a new closure with the existing Factory."}]},{"type":"codeListing","syntax":"swift","code":["container.service.register {","    MockService()","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This new factory closure overrides the original factory closure and clears the associated scope so that the next time this factory is resolved Factory will evaluate the new closure and return an instance of the newly registered object instead."}]},{"anchor":"Mocking-and-Testing","level":2,"type":"heading","text":"Mocking and Testing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If we go back and look at our original view model code one might wonder why we’ve gone to all of this trouble? Why not simply say "},{"type":"codeVoice","code":"let myService = MyService()"},{"type":"text","text":" and be done with it?"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Or keep the container idea, but write something similar to this…"}]},{"type":"codeListing","syntax":"swift","code":["extension Container {","    static var myService: MyServiceType { MyService() }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Well, the primary benefit one gains from using a container-based dependency injection system is that we’re able to change the behavior of the system as needed. Consider the following code:"}]},{"type":"codeListing","syntax":"swift","code":["struct ContentView: View {","    @StateObject var model = ContentViewModel()","    var body: some View {","        Text(model.text())","            .padding()","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Our ContentView uses our view model, which is assigned to a StateObject. Great. But now we want to preview our code. How do we change the behavior of "},{"type":"codeVoice","code":"ContentViewModel"},{"type":"text","text":" so that its "},{"type":"codeVoice","code":"MyService"},{"type":"text","text":" dependency isn’t making live API calls during development?"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It’s easy. Just replace "},{"type":"codeVoice","code":"MyService"},{"type":"text","text":" with a mock that also conforms to "},{"type":"codeVoice","code":"MyServiceType"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"swift","code":["struct ContentView_Previews: PreviewProvider {","    static var previews: some View {","        let _ = Container.shared.myService.register { MockService2() }","        ContentView()","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note the line in our preview code where we’re gone back to our container and registered a new closure on our factory. This function overrides the default factory closure."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now when our preview is displayed "},{"type":"codeVoice","code":"ContentView"},{"type":"text","text":" creates a "},{"type":"codeVoice","code":"ContentViewModel"},{"type":"text","text":" which in turn has a dependency on "},{"type":"codeVoice","code":"myService"},{"type":"text","text":" using shared container."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And when the wrapper asks the factory for an instance of "},{"type":"codeVoice","code":"MyServiceType"},{"type":"text","text":" it now gets a "},{"type":"codeVoice","code":"MockService2"},{"type":"text","text":" instead of the "},{"type":"codeVoice","code":"MyService"},{"type":"text","text":" type originally defined."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is a powerful concept that lets us reach deep into a chain of dependencies and alter the behavior of a system as needed."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"See "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/Testing"},{"type":"text","text":" for more information."}]}]}],"variants":[{"paths":["\/documentation\/factory\/gettingstarted"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/Factory\/documentation\/Factory\/GettingStarted","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Defining a Factory, resolving it, and changing the default behavior."}],"kind":"article","metadata":{"modules":[{"name":"Factory"}],"role":"collectionGroup","title":"Getting Started"},"hierarchy":{"paths":[["doc:\/\/Factory\/documentation\/Factory"]]},"topicSections":[{"title":"Examples","abstract":[{"type":"text","text":"Some code samples demonstration various ways to regsiter and resolve Factory’s."}],"identifiers":["doc:\/\/Factory\/documentation\/Factory\/Registrations","doc:\/\/Factory\/documentation\/Factory\/Resolutions"]}],"references":{"doc://Factory/documentation/Factory/Testing":{"role":"article","title":"Testing","abstract":[{"type":"text","text":"Using Factory for Unit and UI Testing."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Testing","kind":"article","type":"topic","url":"\/documentation\/factory\/testing"},"doc://Factory/documentation/Factory/Scope":{"role":"symbol","title":"Scope","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"Scope"}],"abstract":[{"type":"text","text":"Scopes are used to define the lifetime of resolved dependencies. Factory provides several scope types,"},{"type":"text","text":" "},{"type":"text","text":"including "},{"type":"codeVoice","code":"Singleton"},{"type":"text","text":", "},{"type":"codeVoice","code":"Cached"},{"type":"text","text":", "},{"type":"codeVoice","code":"Graph"},{"type":"text","text":", and "},{"type":"codeVoice","code":"Shared"},{"type":"text","text":"."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Scope","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Scope"}],"url":"\/documentation\/factory\/scope"},"doc://Factory/documentation/Factory":{"role":"collection","title":"Factory","abstract":[{"type":"text","text":"A new approach to Container-Based Dependency Injection for Swift and SwiftUI."}],"identifier":"doc:\/\/Factory\/documentation\/Factory","kind":"symbol","type":"topic","url":"\/documentation\/factory"},"doc://Factory/documentation/Factory/Containers":{"role":"article","title":"Containers","abstract":[{"type":"text","text":"Containers are the cornerstone of Factory 2.0. What are they and how do we use them?"}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Containers","kind":"article","type":"topic","url":"\/documentation\/factory\/containers"},"doc://Factory/documentation/Factory/Factory":{"role":"symbol","title":"Factory","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Factory"}],"abstract":[{"type":"text","text":"A Factory manages the dependency injection process for a specific object or service."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Factory","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Factory"}],"url":"\/documentation\/factory\/factory"},"doc://Factory/documentation/Factory/Resolutions":{"role":"article","title":"Sample Resolutions","abstract":[{"type":"text","text":"There are many ways to use Factory to resolve dependencies. Here are a few examples."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Resolutions","kind":"article","type":"topic","url":"\/documentation\/factory\/resolutions"},"doc://Factory/documentation/Factory/Registrations":{"role":"article","title":"Sample Registrations","abstract":[{"type":"text","text":"There are many ways to register dependencies with Factory. Here are a few examples."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Registrations","kind":"article","type":"topic","url":"\/documentation\/factory\/registrations"},"doc://Factory/documentation/Factory/Scopes":{"role":"collectionGroup","title":"Scopes","abstract":[{"type":"text","text":"Not everything wants to be a Singleton. Learn the power of Scopes."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Scopes","kind":"article","type":"topic","url":"\/documentation\/factory\/scopes"}}}
